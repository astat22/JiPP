<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
<title>Marcin Zawada - Języki i paradygmaty programowania</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="content-style-type" content="text/css">
<link rel="stylesheet" type="text/css" href="Marcin%20Zawada%20-%20J%C4%99zyki%20i%20paradygmaty%20programowania_pliki/index.css" media="all">
</head>
<body>
 
    <div class="headerbar">
        <div class="inner"><span class="corners-top"><span></span></span>
	    <div class="postbody">
	        <h3 class="first">Języki i paradygmaty programowania</h3>
                <ul class="leftside">
                    <li>Wykład:
                    <ul class="leftside">
                        <li>Czwartek, godz. 11:15-12:00 A-1 204</li>
                    </ul>
                    </li>
                    <li>Ćwiczenia:
                    <ul class="leftside">
                        <li>Poniedziałek, godz. 12:15 C-7 303A (Marcin Kik)</li>
                        <li>Poniedziałek, godz. 13:15 C-7 303A (Marcin Kik)</li>
                        <li>Poniedziałek, godz. 14:15 C-7 303A (Marcin Kik)</li>
                    </ul>
                    </li>
                    <li>Laboratorium:
                    <ul class="leftside">
                        <li>Poniedziałek, godz. 18:55 D-1 317.3 (Przemysław Kobylański)</li>
                        <li>Wtorek, godz. 11:15 D-1 317.3</li>
                        <li>Środa, godz. 7:30 D-1 317.3 (Piotr Syga)</li>
                        <li>Środa, godz. 15:15 D-1 317.3 (Marcin Kik)</li>
                        <li>Czwartek, godz. 9:15 D-1 317.3 (Marcin Kik)</li>
                        <li>Piątek, godz. 15:15 D1 317.3 (Piotr Syga)</li>
                    </ul>
                    </li>
		</ul>
	    </div>

	    <span class="corners-bottom"><span></span></span>
        </div>
    </div>


    <div class="headerbar">
        <div class="inner"><span class="corners-top"><span></span></span>
	    <div class="postbody">
	        <h4 class="first">Zasady zaliczenia kursu</h4>
                <ul class="leftside">
                    <li>Zasady zaliczenia laboratorium: aby uzyskać pozytywną
                    ocenę należy zdobyć co najmniej 15 punktów łącznie z dwóch
                    testów. Testy odbywają się w <span style="color:red">47</span> i <span style="color:red"><strike>3</strike></span> <span style="color:red">4</span> tygodniu z <a href="https://prac.im.pwr.wroc.pl/%7Ezawada/kalendarz-2013-2014.pdf">kalendarza</a> oraz na każdym
                    można zdobyć po 15 punktów. Punkty można również
                    zdobyć za rozwiązanie dodatkowych zadań w czasie trwania laboratorium.</li>
                    <li>Zasady zaliczenia ćwiczeń: dwa kolokwia </li>
                    <li>Oceną z kursu będzie średnia ocen z laboratorium oraz ćwiczeń.
                        Wykładowca przy wpisywaniu ocen od 4.0 w górę może
                        zweryfikować wiedzę studenta za pomocą kilku pytań z
                        tematyki wykładu.
                </li></ul>
	    </div>
	    <span class="corners-bottom"><span></span></span>
        </div>
    </div>

    <div class="headerbar">
        <div class="inner"><span class="corners-top"><span></span></span>
	    <div class="postbody">
                <h4 class="first">Wykłady</h4>
                <ul class="leftside">
                    <li><a href="https://prac.im.pwr.wroc.pl/%7Ezawada/jipp2013/jipp2013w1.php">Wykład 1</a> 3.10.2013
                    <ul class="leftside">
                        <li><a href="http://wazniak.mimuw.edu.pl/index.php?title=Programowanie_obiektowe">Programowanie i projektowanie obiektowe</a></li>
                    </ul></li>
                    <li><a href="https://prac.im.pwr.wroc.pl/%7Ezawada/jipp2013/jipp2013w2.php">Wykład 2</a> 10.10.2013
                    <ul class="leftside">
                        <li><a href="http://www.sgi.com/tech/stl">Standard Template Library</a></li>
                        <li><a href="http://www.boost.org/">Boost</a></li>
                    </ul></li>
                    <li>Wykład 3 17.10.2013
                    <ul class="leftside">
                        <li><a href="http://media.ccc.de/browse/congress/2010/27c3-4159-en-reverse_engineering_mos_6502.html">Reverse Engineering the MOS 6502 CPU</a></li>
                        <li><a href="http://visual6502.org/JSSim/index.html"> Visual 6502 </a></li>
                    </ul></li>
                    <li><a href="https://prac.im.pwr.wroc.pl/%7Ezawada/jipp2013/jipp2013w4.php">Wykład 4</a> 24.10.2013
                    <ul class="leftside">
                        <li><a href="http://www.sgi.com/tech/stl">Standard Template Library</a></li>
                        <li><a href="http://www.boost.org/">Boost</a></li>
                        <li><a href="http://sourceforge.net/projects/blitz/">Blitz++</a></li>
                    </ul></li>
                    <li><a href="https://prac.im.pwr.wroc.pl/%7Ezawada/jipp2013/jipp2013w5.php">Wykład 5</a> 7.11.2013
                    <ul class="leftside">
                        <li><a href="http://www.python.org/">Python</a></li>
                        <li><a href="http://www.python.org/dev/peps/">Python Enhancement Proposals (PEPs)</a></li>
                    </ul></li>
                    <li><a href="https://prac.im.pwr.wroc.pl/%7Ezawada/jipp2013/jipp2013w6.php">Wykład 6</a> 14.11.2013</li>
                    <li><a href="https://prac.im.pwr.wroc.pl/%7Ezawada/jipp2013/jipp2013w7.php">Wykład 7</a> 28.11.2013
                    <ul class="leftside">
                        <li><a href="http://caml.inria.fr/">OCAML</a></li>
                        <li><a href="http://wazniak.mimuw.edu.pl/index.php?title=Programowanie_funkcyjne">Programowanie funkcyjne</a></li>
                        <li><a href="http://wazniak.mimuw.edu.pl/index.php?title=Paradygmaty_programowania/Wyk%C5%82ad_8:_U_podstaw_programowania_funkcyjnego_%E2%80%94_rachunek_lambda">Rachunek lambda</a></li>
                        <li><a href="http://caml.inria.fr/pub/docs/oreilly-book/">Developing Applications With Objective CAML</a></li>
                        <li><a href="http://www.ffconsultancy.com/ocaml/index.html">Przykłady</a></li>
                        <li><a href="http://queue.acm.org/detail.cfm?id=2038036">OCaml for the Masses</a> (<a href="http://portal.acm.org/ft_gateway.cfm?id=2038036&amp;type=pdf">PDF</a>)</li>
                    </ul></li>
                    <li><a href="https://prac.im.pwr.wroc.pl/%7Ezawada/jipp2013/jipp2013w8.php">Wykład 8</a> 5.12.2013
                    </li><li><a href="https://prac.im.pwr.wroc.pl/%7Ezawada/jipp2013/jipp2013w9.php">Wykład 9</a> 12.12.2013
                    </li><li><a href="https://prac.im.pwr.wroc.pl/%7Ezawada/jipp2013/jipp2013w10.php">Wykład 10</a> 12.12.2013
                                         <ul class="leftside">
                        <li><a href="http://www.erlang.org/">Erlang</a></li>
                        <li><a href="http://www.erlang.org/download/getting_started-5.4.pdf">Wprowadzenie do Erlanga</a></li>
                        <li><a href="http://couchdb.apache.org/">Zastosowania - CouchDB</a></li>
                        <li><a href="http://www.facebook.com/note.php?note%5Fid=51412338919&amp;id=9445547199&amp;index=1">Zastosowania - Facebook Chat</a></li>
                    </ul></li>

<li>
<a href="https://prac.im.pwr.wroc.pl/%7Ezawada/jipp2013/jipp2013w11.php">Wykład 11</a> 16.01.2014
<ul class="leftside">
<li><a href="http://www.haskell.org/">Haskell</a></li>
<li><a href="http://www.haskell.org/ghc">The Glasgow Haskell Compiler</a></li>
<li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell for Great Good!</a></li>
</ul>
</li>

<li>
<a href="https://prac.im.pwr.wroc.pl/%7Ezawada/jipp2013/jipp2013w12.php">Wykład 12</a> 23.01.2014
<ul class="leftside">
<li>
<a href="http://wazniak.mimuw.edu.pl/index.php?title=Teoria_kategorii_dla_informatyk%C3%B3w"> Teoria kategorii dla informatyków </a>
<ul class="leftside">
<li><a href="http://wazniak.mimuw.edu.pl/index.php?title=Teoria_kategorii_dla_informatyk%C3%B3w/Wyk%C5%82ad_11:_Monady">Monady</a></li>
</ul>
</li><li><a href="http://wazniak.mimuw.edu.pl/index.php?title=Paradygmaty_programowania/Wyk%C5%82ad_12:_Programowanie_funkcyjne_w_Haskellu_III">Programowanie w Haskallu</a></li>
</ul>
</li>



                </ul>
	    </div>
	    <span class="corners-bottom"><span></span></span>
        </div>
    </div>



    <div class="headerbar">
        <div class="inner"><span class="corners-top"><span></span></span>
	    <div class="postbody">
                <h4 class="first">Ćwiczenia</h4>
                <ul class="leftside">
                    <li>Diagramy UML - 7.10.2013
                    <ul class="leftside">
                        <li><a href="http://www.omg.org/spec/UML/">UML</a></li>
                        <li><a href="http://staruml.sourceforge.net/en/">StarUML</a> (<a href="http://sourceforge.net/projects/staruml/files/staruml/5.0/">Win32</a>),</li>
                        <li><a href="http://uml.sourceforge.net/">Umbrello</a></li>
                    </ul>
                    </li>
                    <li><a href="https://prac.im.pwr.wroc.pl/%7Ezawada/jipp2013/lista1.php">Lista 1</a> - 7, 14.10.2013</li>
                    <li>Diagramy przebiegu - 21.10.2013</li>
                    <li><a href="https://prac.im.pwr.wroc.pl/%7Ezawada/jipp2013/lista2.php">Lista 2</a> - 21, 28.10.2013</li>
                    <li>Logika Hoare - teoria + przykłady - 4, 12.11.2013
                    <ul class="leftside">
                        <li><a href="http://en.wikipedia.org/wiki/Hoare_logic">Logika Hoare'a</a> 
                            <a href="http://en.wikipedia.org/w/index.php?title=Special:Book&amp;bookcmd=render_article&amp;arttitle=Hoare+logic&amp;oldid=381298596&amp;writer=rl">(pdf)</a></li>
                    </ul>
                    </li>
                    <li>Kolokwium I - Listy 1 i 2 - 18.11.2013</li>
                    <li><a href="https://prac.im.pwr.wroc.pl/%7Ezawada/jipp2013/lista3.php">Lista 3</a> - 25.11.2013, 2.12.2013 </li>
                    <li>Rachunek Lambda - teoria + przykłady - 9, 16.12.2013
                    <ul class="leftside">
                        <li><a href="http://wazniak.mimuw.edu.pl/index.php?title=Paradygmaty_programowania/Wyk%C5%82ad_8:_U_podstaw_programowania_funkcyjnego_%E2%80%94_rachunek_lambda">Rachunek lambda</a></li>
                    </ul>
                    </li>
                    <li><a href="https://prac.im.pwr.wroc.pl/%7Ezawada/jipp2013/lista4.php">Lista 4</a> - 16.12.2013 i 9,13.01.2014</li>
                    <li>Kolokwium II - Listy 3 i 4 - 20.01.2014</li>
                </ul>
	    </div>
	    <span class="corners-bottom"><span></span></span>
        </div>
    </div>


    <div class="headerbar">
        <div class="inner"><span class="corners-top"><span></span></span>
	    <div class="postbody">
	        <h4 class="first">Lista 0 (Lab)</h4>
                <ol class="leftside">
                    <li>Zainstaluj języki programowania Python, Erlang, OCAML, Haskell oraz
                    w każdym uruchom poniższy program szybkiego sortowania
                    <ul class="leftside">
                        <li> <a href="http://www.python.org/">Python</a><br><br>
                            <center>
<textarea rows="6" cols="85" readonly="readonly" style="color: white; background-color: #222222;">def quicksort(L):
    if len(L) &lt;= 1: return L
    pivot = L[0]
    left = quicksort( [ x for x in L[1:] if x &lt; pivot ] ) 
    right = quicksort( [ x for x in L[1:] if x &gt;= pivot ] )
    return  left + [pivot] + right
    </textarea>
</center>
<br>                    </li>
                        <li> <a href="http://www.erlang.org/">Erlang</a><br><br>
                            <center>
<textarea rows="7" cols="85" readonly="readonly" style="color: white; background-color: #222222">-module(test).
-export([quicksort/1]).

quicksort([]) -&gt;
    [];
quicksort([Pivot | T]) -&gt; 
    quicksort([ X || X &lt;- T, X &lt; Pivot ]) ++ [Pivot] ++ quicksort([ X || X &lt;- T, X &gt;= Pivot ]).
</textarea>
                            </center>
                            <br>
                        </li>
                        <li> <a href="http://caml.inria.fr/">OCAML</a> <br><br>
                            <center>
<textarea rows="6" cols="85" readonly="readonly" style="color: white; background-color: #222222">let rec quicksort = function
  | [] -&gt; []
  | pivot :: rest -&gt;
     let is_less x = x &lt; pivot in
     let left, right = List.partition is_less rest in
        quicksort left @ [pivot] @ quicksort right;;
</textarea>
                            </center>
                            <br>
                        </li>
                    <li> <a href="http://haskell.org/ghc">Haskell (ghc)</a><br><br>
                            <center>
<textarea rows="5" cols="85" readonly="readonly" style="color: white; background-color: #222222">quicksort [] = []
quicksort (x:xs) = quicksort left ++ [x] ++ quicksort right
                where
                  left = [y | y &lt;- xs, y &lt; x]
                  right = [y | y &lt;- xs, y &gt;= x]
</textarea>
                            </center>
                            <br>
                        </li>
                    </ul>
                    </li>
                </ol>


    <h4 class="first">Lista 1 (Lab)</h4>
    <ol class="leftside">
        <li>(C++) Zaprojektować i napisać w języku C++:
            <ul class="leftside">
                <li>Klasę <b>Matrix</b> parametryzowaną typem
                elementów macierzy kwadratowej z operacjami
                <ul class="leftside">
                    <li>"+","-","*" - macierzy (ze sprawdzaniem wymiarów macierzy)</li>
                    <li>"=" - przypisania</li>
                    <li>element(i,j) - funkcja zwracająca element z wiersza <i>i</i> i kolumny <i>j</i>.
                </li></ul></li>
                <li>Klasę <b><a href="http://pl.wikipedia.org/wiki/Macierz_rzadka">SparseMatrix</a></b> rozszerzającą klasę <b>Matrix</b>.
            Obiekty tej klasy będą macierzami rzadkimi, tzn. takimi, których większość elementów
            jest zerem. Implementacja polega na pamiętaniu tylko elementów niezerowych macierzy.
            Należy przewidzieć konstruktor tworzący macierz rzadką ze zwykłej tablicy oraz destruktory.
            W implementacji należy wykorzystać wzorzec klasy <b>Dictionary</b>.
            <br><br>
<pre>template &lt; class K, class V &gt;
class Dictionary {
protected:
   ...
public:
   Dictionary();
   
   // zwraca wartość powiązaną
   // z kluczem 'key'
   V get(K key);
   
   // wstawia parę '(key, value)' do słownika
   void put(K key, V value);
   
   // sprawdza, czy para o kluczu 'key'
   // istnieje w słowniku
   int check(K key);
};
</pre></li>
        </ul><br></li></ol>

    <h4 class="first">Lista 2 (Lab)</h4>
    <ol class="leftside">
        <li>(C++) Przepisz algorytm sortowania bąbelkowego z wykorzystaniem metaprogramowania z wykładu.
            Zrób tabelkę porównującą czasy wykonywania z klasycznym algorytmem dla N=1,2,4,8,10,16.</li>
        <li> (C++) Napisz klasę <b>Matrix</b> pozwalającą na wszystkie podstawowe operacje na macierzach <i>NxM</i> <b>(+,-,*,T,det,inv)</b>.
        Ponadto, wykorzystując operacje na szablonach zoptymalizuj jak najwięcej z nich.</li>
    </ol>
    <br>
    <h4 class="first">Lista 3 (Lab)</h4>
    <ol class="leftside">
        <li>(PYTHON) Zaprogramuj
        <ul class="leftside">
            
            <li>funkcję <i>silnia(n)</i> liczącą silnie n! dla n od 0 do 10000</li>
            
            <li>funkcję <i>pierwsza(n)</i> zwracająca listę liczb pierwszych nie większych niż n
                np. pierwsza(6) wraca listę [2, 3, 5]</li>

            <li>funkcję <i>rozklad(n)</i>, która rozkłada n na czynniki pierwsze i jako
                wynik wraca listę par [(p1,a1), (p2,a2), (pk, ak)]
                taką, że p1^a1 p2^a2 ... pk^ak.

            </li><li>funkcję <i>silniaZ(n)</i> liczącą silnie n! dla n od 0 do 10000 oraz
                jako wynik wraca liczbę zer na końcu n!</li>

        </ul></li>

        <li>(PYTHON) Napisz program, który czyta plik w formacie CSV oraz następnie
        przerabia go na tabelkę w formacie HTML i zapisuje do pliku</li>

        <li>(PYTHON) Napisz program, który pobiera ze strony
        <a href="http://www.weather.com/outlook/travel/businesstraveler/local/PLXX0029">
        http://www.weather.com/outlook/travel/businesstraveler/local/PLXX0029</a>
        aktualną temperaturę we Wrocławiu oraz wyświetla ją na ekranie w stopniach Celsjusza.
        <br><br>
        Przykładowy wynik działania programu:<br>
<pre>    Wroclaw: 5 stopni
</pre>
<br></li>
    <li>(PYTHON) Napisz program, który rysuje na ekranie w trybie znakowym wykres funkcji
         zmiennej x. Wskazówka: utwórz  ,,tablicę dwuwymiarową'' o wymiarach 80x24
         i narysuj wykres w tej tablicy. Następnie wynik wyświetl na ekranie.

<pre>        Podaj funkcje f(x) = sin(x)
        Podaj początek przedziału a = -pi
        Podaj koniec przedziału b = pi
                                        |                                       
                                        |                                       
                                        |              ***********              
                                        |           ***           ***           
                                        |         **                 **         
                                        |        *                     *        
                                        |      **                       **      
                                        |     *                           *     
                                        |   **                             **   
                                        |  *                                 *  
                                        | *                                   * 
                                        |*                                     *
----------------------------------------|---------------------------------------
  *                                   * |                                       
   *                                 *  |                                       
    **                             **   |                                       
      *                           *     |                                       
       **                       **      |                                       
         *                     *        |                                       
          **                 **         |                                       
            ***           ***           |                                       
               ***** *****              |                                       
                    *                   |                                       
                                        |
</pre>
</li>
    <li>(PYTHON) Napisz program kalkulator, który pobiera wprowadzone wartości oraz funkcje
         z klawiatury następnie podaje wynik. W przypadku błędnych danych zgłasza błąd.
         Przykładowa sesja:
<pre>    Kalkulator
    [1]: 2+5*10
        52
    [2]: sin(0.5)+cos(0.3)
        1.434762027729809
    [3]: 2^100
        1267650600228229401496703205376
</pre>
</li>
    <li>(PYTHON) Napisz generator, który generuje:
        <ul class="leftside">
            <li>kolejne liczby od 1,...,n</li>
	    <li>kolejne liczby Fibonacciego do n</li>
        </ul>
    </li>
    </ol>
    <br><br>


    <h4 class="first">Lista 4 (Lab)</h4>
    <ol class="leftside">
        <li>(OCAML) Zaprogramuj
        <ul class="leftside">
            <li>funkcję <i>primes : int -&gt; int list</i> zwracająca listę liczb pierwszych nie większych niż n
                (wykorzystaj <a href="http://pl.wikipedia.org/wiki/Sito_Eratostenesa">Sito Eratostenesa</a>)
<pre># primes 6;;
- : int list = [2; 3; 5]
</pre></li>
            

            <li>funkcję liczącą długość danej listy <b>length: 'a list -&gt; int</b>
<pre># length [1;2;3;4];;
- : int = 4
</pre></li>

            <li>funkcję wracającą n-ty element listy <b>nth: 'a list -&gt; int -&gt; 'a</b>
<pre># nth [1;2;3;4] 2;;
- : int = 3
</pre></li>

            <li>funkcją sprawdzająca, czy dany element x należy do listy l <b>mem: 'a -&gt; 'a list -&gt; bool</b>
<pre># mem 2 [1;2;3;4];;
- : bool = true
# mem 5 [1;2;3;4];;
- : bool = false
</pre></li>
            <li>funkcją zwracającą ostatni element listy <b>last: 'a list -&gt; 'a</b>
<pre># last [1;2;3;4];;
- : int = 4
</pre></li>
            <li>funkcję <b>merge</b> łączącą dwie posortowane listy w jedną <b>merge: ('a -&gt; 'a -&gt; bool) -&gt; 'a list -&gt; 'a list -&gt; 'a list</b>
<pre># merge (&lt;) [1;4;5] [1;2;3];;
- : int list = [1; 1; 2; 3; 4; 5]
</pre></li>
            <li>funkcję <b>sort</b> sortującą listę algorytmem przez scalanie <b>sort: ('a -&gt; 'a -&gt; bool) -&gt; 'a list -&gt; 'a list</b>
<pre># sort (&lt;) [4;1;3;2];;
- : int list = [1; 2; 3; 4]
</pre></li>
            <li>funkcję <b>uniq</b> eliminującą powtórzenia z listy <b>uniq: 'a list -&gt; 'a list</b>
<pre>uniq [1;2;1;1;3;3;4;4];;
- : int list = [1; 2; 3; 4]
</pre></li>
        </ul></li>
    <li> (OCAML) Zaprogramuj
        <ul class="leftside">
        <li>funkcję <b>append</b> łączącą dwie listy <b>append: 'a list -&gt; 'a list -&gt; 'a list</b>
<pre># append [1;2;3] [4;5;6];;
- : int list = [1; 2; 3; 4; 5; 6]
</pre></li>
        <li>funkcję <b>rev</b> odwracającą listę <b>rev: 'a list -&gt; 'a list</b>
<pre># rev [1;2;3];;
- : int list = [3; 2; 1]
</pre></li>
        <li>funkcje <b>sigma: int list -&gt; int</b> i <b>pi: int list -&gt; int</b> wracającą odpowiednio
        sumę i iloczyń liczb całkowitych z listy</li>
        <li>funkcję <b>flat: 'a list list -&gt; 'a list</b> "spłaszczającą" listę list
<pre># flat [[1;2];[3;4]];;  
- : int list = [1; 2; 3; 4]
</pre></li>
            <li>funkcję <b>merge</b> łączącą dwie posortowane listy w jedną <b>merge: ('a -&gt; 'a -&gt; bool) -&gt; 'a list -&gt; 'a list -&gt; 'a list</b>
<pre># merge (&lt;) [1;4;5] [1;2;3];;
- : int list = [1; 1; 2; 3; 4; 5]
</pre></li>
            <li>funkcję <b>sort</b> sortującą listę algorytmem przez scalanie <b>sort: ('a -&gt; 'a -&gt; bool) -&gt; 'a list -&gt; 'a list</b>
<pre># sort (&lt;) [4;1;3;2];;
- : int list = [1; 2; 3; 4]
</pre></li>
            <li>funkcję <b>uniq</b> eliminującą powtórzenia z listy <b>uniq: 'a list -&gt; 'a list</b>
<pre>uniq [1;2;1;1;3;3;4;4];;
- : int list = [1; 2; 3; 4]
</pre></li>
        </ul></li>
    </ol>
<br>
    <h4 class="first">Lista 5 (Lab)</h4>
    <ol class="leftside">
        <li>(OCAML) Zaprogramuj
        <ul class="leftside">
            <li>funkcję <b>distinctpairs : 'a list -&gt; ('a * 'a) list</b> która generuje wszystkie różne pary
<pre> distinctpairs [1;2;3;4];;
- : (int * int) list = [(1, 2); (1, 3); (1, 4); (2, 3); (2, 4); (3, 4)]
</pre></li>
            <li>funkcję <b>allsets : int -&gt; 'a list -&gt; 'a list list</b> która generuje wszystkie podzbiory <i>k</i> elementowe
<pre># allsets 1 [1;2;3];;
- : int list list = [[1]; [2]; [3]]
# allsets 2 [1;2;3];;
- : int list list = [[1; 2]; [1; 3]; [2; 3]]
</pre></li></ul>
        </li><li>(OCAML) Zadeklaruj typ 'expr' przedstawiony na 
wykładzie. Uzupełnij go o operacje '-','/' oraz '^'. Napisz program 
obliczający pochodną oraz
            funkcję 'simplify' upraszczającą otrzymane wyrażenia.</li>
        <li>(OCAML) Zadeklaruj typ 'formula' przedstawiony na wykładzie. Napisz program wartościujący formulę oraz
            funkcję upraszczającą 'simplify'.</li>
    </ol>
    <br>

    <h4 class="first">Lista 6 (Lab)</h4>
    <ol class="leftside">
        <li>(ERLANG) Zaprogramuj
        <ul class="leftside">
            <li>funkcję <i>filter</i> która dla danej listy liczb całkowitych oraz liczby całkowitej <i>n</i> wróci
                wszystkie liczby z listy mniejszy lub równe <i>n</i>
<pre>&gt; filter([1,2,3,4,5], 3).
[1,2,3]
</pre></li>
            <li>funkcję <i>reverse</i> która odwróci porządek elementów na liście
<pre>&gt; reverse([1,2,3]).
[3,2,1]
</pre></li>
            <li>funkcję <i>concatenate</i> która połączy listę list
<pre>&gt; concatenate([[1,2,3], [], [4, five]]).
[1,2,3,4,five]
</pre></li>
            <li>funkcję <i>flatten</i> która mając listę list wróci "płaską" listę
<pre>&gt; flatten([[1,[2,[3],[]]], [[[4]]], [5,6]]).
[1,2,3,4,5,6]
</pre></li>
            <li>funkcję <i>sort</i> sortującą listę algorytmem przez scalanie
<pre>&gt; sort([5,2,3,4,1]).
[1,2,3,4,5]
</pre></li>
        </ul></li>
        <li>(ERLANG) Zmodyfikuj serwer <b>echo</b> z wykładu w taki sposób, że po uruchomieniu proces
            <i>loop</i> nie kończy swojego działania, ale można wysyłać komunikaty do tego procesu
            również z konsoli. Następnie zmodyfikuj go tak, że jeśli wyślemy do tego procesu liczbę <i>n</i>
            to jako wynik dostaniemy na ekranie <i>n!</i> natomiast, jeśli wyślemy 'stop' to proces
            kończy swoje działanie.</li>
        <li>(ERLANG) Napisz program który tworzy <i>N</i> procesów połączonych w ring (tzn pierwszy 
        proces wysyła wiadomości do drugiego, drugi to trzeciego i tak dalej natomiast ostatni <i>N</i> wysyła
        do pierwszego). Po uruchomieniu procesy te wyślą <i>M</i> wiadomości 'Message' w około ringu i zakończą
        swoje działanie jeśli otrzymają wiadomość 'quit'. Program możemy uruchomić np. tak
<pre>&gt; ring:start(M,N,Message).
</pre>
    </li></ol>
    <br>

    <h4 class="first">Lista 7 (Lab)</h4>
    <ol class="leftside">
        <li>(ERLANG) Wykorzystując przykład serwera tcp z wykładu. Napisz program klienta który wysyła wartości
            od 1 do 20 do serwera i odpowiedzi wyświetla na ekranie. Serwer wraca silnie z otrzymanych
             wartości. (Pisząc klienta wykorzystaj dokumentacje <a href="http://www.erlang.org/doc/man/gen_tcp.html">gen_tcp</a>)</li>
    </ol>
    <br>
    <h4 class="first">Lista 8 (Lab)</h4>
    <ol class="leftside">
        <li>(HASKELL) Zaprogramuj
            <ul class="leftside">
                <li>funkcję <i>pitagoras :: [(Integer,Integer,Integer)]</i> generującą listę trójkątów pitagorejskich, wykorzystując listy nieskończone
<pre>&gt; take 5 pitagoras
[(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17)]
</pre></li>

                <li>funkcję <i>prime :: [Int]</i> generującą listę liczb pierwszych wykorzystując listy nieskończone oraz metodę sita Eratostenesa
<pre>&gt; take 5 prime
[2, 3, 5, 7, 11]
</pre></li>

                <li>funkcję <i>iSort :: [Int] -&gt; [Int]</i> sortującą podany ciąg przez algorytm sortowania przez wstawianie (Insertion Sort)</li>


                <li>funkcję <i>MergeSort :: [Int] -&gt; [Int]</i> sortującą podany ciąg przez scalanie</li>

                <li>funkcję <i>sorted :: [Int] -&gt; Bool</i> sprawdzającą czy podany ciąg jest posortowany
<pre>&gt; sorted [1,2,3,4]
True
&gt; sorted [3,2,1,4]
False
</pre></li>
    </ul></li>
    </ol>
    <br>
            </div>
	    <span class="corners-bottom"><span></span></span>
        </div>
    </div>





</body></html>